#pragma once
#include "VulkanBackendStructures.h"

namespace coral
{
    static uint32_t findMemoryTypeIndex(VkPhysicalDevice physicalDevice, uint32_t allowedTypes, VkMemoryPropertyFlags properties)
    {
        // Get properties of physical device memory
        VkPhysicalDeviceMemoryProperties memoryProperties;
        vkGetPhysicalDeviceMemoryProperties(physicalDevice, &memoryProperties);

        for (uint32_t i = 0; i < memoryProperties.memoryTypeCount; i++)
        {
            if ((allowedTypes & (1 << i)) // Index of memory type must match corresponding bit in allowedTypes
                && (memoryProperties.memoryTypes[i].propertyFlags & properties) == properties) // Desired property bit flags are part of memory type's property flags
            {
                // This memory type is valid, so return its index
                return i;
            }
        }
        return -1;
    }

    static void createBuffer(VkPhysicalDevice physicalDevice, VkDevice device, VkDeviceSize bufferSize, VkBufferUsageFlags bufferUsage,
        VkMemoryPropertyFlags bufferProperties, VkBuffer* buffer, VkDeviceMemory* bufferMemory)
    {
        // CREATE VERTEX BUFFER
        // Information to create a buffer (doesn't include assigning memory)
        VkBufferCreateInfo bufferInfo = {};
        bufferInfo.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
        bufferInfo.size = bufferSize; // Size of buffer (size of 1 vertex * number of vertices)
        bufferInfo.usage = bufferUsage; // Multiple types of buffer possible
        bufferInfo.sharingMode = VK_SHARING_MODE_EXCLUSIVE; // Similar to Swap Chain images, can share vertex buffers

        VkResult result = vkCreateBuffer(device, &bufferInfo, nullptr, buffer);
        if (result != VK_SUCCESS)
        {
            throw std::runtime_error("Failed to create a Vertex Buffer!");
        }

        // GET BUFFER MEMORY REQUIREMENTS
        VkMemoryRequirements memRequirements;
        vkGetBufferMemoryRequirements(device, *buffer, &memRequirements);

        // ALLOCATE MEMORY TO BUFFER
        VkMemoryAllocateInfo memoryAllocInfo = {};
        memoryAllocInfo.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
        memoryAllocInfo.allocationSize = memRequirements.size;
        memoryAllocInfo.memoryTypeIndex = findMemoryTypeIndex(physicalDevice, memRequirements.memoryTypeBits, // Index of memory type on Physical Device that has required bit flags
            bufferProperties); // VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT	: CPU can interact with memory
        // VK_MEMORY_PROPERTY_HOST_COHERENT_BIT	: Allows placement of data straight into buffer after mapping (otherwise would have to specify manually)
        // Allocate memory to VkDeviceMemory
        result = vkAllocateMemory(device, &memoryAllocInfo, nullptr, bufferMemory);
        if (result != VK_SUCCESS)
        {
            throw std::runtime_error("Failed to allocate Vertex Buffer Memory!");
        }

        // Allocate memory to given vertex buffer
        vkBindBufferMemory(device, *buffer, *bufferMemory, 0);
    }

    static void copyBuffer(VkDevice device, VkQueue transferQueue, VkCommandPool transferCommandPool,
        VkBuffer srcBuffer, VkBuffer dstBuffer, VkDeviceSize bufferSize)
    {
        // Command buffer to hold transfer commands
        VkCommandBuffer transferCommandBuffer;

        // Command Buffer details
        VkCommandBufferAllocateInfo allocInfo = {};
        allocInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO;
        allocInfo.level = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
        allocInfo.commandPool = transferCommandPool;
        allocInfo.commandBufferCount = 1;

        // Allocate command buffer from pool
        vkAllocateCommandBuffers(device, &allocInfo, &transferCommandBuffer);

        // Information to begin the command buffer record
        VkCommandBufferBeginInfo beginInfo = {};
        beginInfo.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
        beginInfo.flags = VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT; // We're only using the command buffer once, so set up for one time submit

        // Begin recording transfer commands
        vkBeginCommandBuffer(transferCommandBuffer, &beginInfo);

        // Region of data to copy from and to
        VkBufferCopy bufferCopyRegion = {};
        bufferCopyRegion.srcOffset = 0;
        bufferCopyRegion.dstOffset = 0;
        bufferCopyRegion.size = bufferSize;

        // Command to copy src buffer to dst buffer
        vkCmdCopyBuffer(transferCommandBuffer, srcBuffer, dstBuffer, 1, &bufferCopyRegion);

        // End commands
        vkEndCommandBuffer(transferCommandBuffer);

        // Queue submission information
        VkSubmitInfo submitInfo = {};
        submitInfo.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
        submitInfo.commandBufferCount = 1;
        submitInfo.pCommandBuffers = &transferCommandBuffer;

        // Submit transfer command to transfer queue and wait until it finishes
        vkQueueSubmit(transferQueue, 1, &submitInfo, VK_NULL_HANDLE);
        vkQueueWaitIdle(transferQueue);

        // Free temporary command buffer back to pool
        vkFreeCommandBuffers(device, transferCommandPool, 1, &transferCommandBuffer);
    }
}
